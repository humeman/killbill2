package today.tecktip.killbill.backend.gameserver.games.basic;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import today.tecktip.killbill.backend.gameserver.SpringMessageHandler;
import today.tecktip.killbill.backend.gameserver.games.basic.commands.BasicRecvEntityStateCommand.RecvEntityStateInvokeContext;
import today.tecktip.killbill.common.exceptions.MessageFailure;
import today.tecktip.killbill.common.gameserver.data.Coordinates;
import today.tecktip.killbill.common.gameserver.games.GameType;
import today.tecktip.killbill.common.gameserver.messages.MessageDataType;
import today.tecktip.killbill.common.maploader.directives.EntityDirective.EntityType;
import today.tecktip.killbill.common.misc.TimestampedValue;

public abstract class BasicEntityState {
    /**
     * Logs go here
     */
    private static final Logger LOGGER = LoggerFactory.getLogger(BasicEntityState.class);

    protected final BasicGameState parent;

    private TimestampedValue<Coordinates> coords;

    private TimestampedValue<Integer> rotation;

    private TimestampedValue<Integer> health;

    private TimestampedValue<String> heldItemTexture;

    private TimestampedValue<Integer> state;

    private String texturePrefix;

    private final EntityType type;

    protected List<EntityStateFieldFilter> filter;

    protected final int id;

    /**
     * Constructs a new entity state for the BASIC game type.
     */
	public BasicEntityState(final int id, final BasicGameState parent, final EntityType type, final Coordinates spawnPoint, final int rotation, final int health, final String texturePrefix) {
        this.id = id;
        this.parent = parent;
        this.type = type;
        this.texturePrefix = texturePrefix;
        this.health = new TimestampedValue<>(health);
        coords = new TimestampedValue<>(spawnPoint);
        this.rotation = new TimestampedValue<>(rotation);
        heldItemTexture = new TimestampedValue<>("none");
        state = new TimestampedValue<>(0);
        filter = new ArrayList<>(EntityStateFieldFilter.values().length);
	}

    /**
     * Runs movement/attack tasks on each game tick (1/20s).
     * @param delta Time in seconds since last tick
     * @return If true, the entity is removed after this tick
     */
    public abstract boolean onTick(final float delta);

    /**
     * Gets the entity's current coordinates.
     * @return Coordinates
     */
    public Coordinates getCoordinates() {
        return coords.get();
    }

    /**
     * Sets the entity's current coordinates.
     * @param coords New coordinates
     */
    public void setCoordinates(final Coordinates coords) {
        if (coords.x() == this.coords.get().x() && coords.y() == this.coords.get().y()) return;
        filter.add(EntityStateFieldFilter.COORDINATES);
        this.coords.set(coords);
    }

    /**
     * Sets the entity's current coordinates if the specified timestamp is after the current value's.
     * @param createdAt When the new value was generated by the other end
     * @param coords New coordinates
     */
    public void setCoordinates(final Instant createdAt, final Coordinates coords) {
        this.coords.set(createdAt, coords);
    }

    /**
     * Gets the entity's rotation.
     * @return Rotation in degrees, 0 to 359 inclusive
     */
    public int getRotation() {
        return rotation.get();
    }

    /**
     * Sets the entity's rotation.
     * @param color New rotation, 0 to 359 inclusive
     */
    public void setRotation(final int rotation) {
        if (rotation == this.rotation.get()) return;
        filter.add(EntityStateFieldFilter.ROTATION);
        this.rotation.set(rotation);
    }

    /**
     * Sets the entity's rotation if the specified timestamp is after the current value's.
     * @param createdAt When the new value was generated by the other end
     * @param rotation New rotation
     */
    public void setRotation(final Instant createdAt, final int rotation) {
        this.rotation.set(createdAt, rotation);
    }
    
    /**
     * Gets the entity's type.
     * @return entity type
     */
    public EntityType getType() {
        return type;
    }

    /**
     * Gets the entity's health.
     * @return Health
     */
    public int getHealth() {
        return health.get();
    }

    /**
     * Sets the entity's health.
     * @param color New health
     */
    public void setHealth(final int health) {
        if (health == this.health.get()) return;
        filter.add(EntityStateFieldFilter.HEALTH);
        this.health.set(health);
    }

    /**
     * Sets the entity's health if the specified timestamp is after the current value's.
     * @param createdAt When the new value was generated by the other end
     * @param health New health
     */
    public void setHealth(final Instant createdAt, final int health) {
        this.health.set(createdAt, health);
    }   

    /**
     * Gets the entity's state.
     * @return State
     */
    public int getState() {
        return state.get();
    }

    /**
     * Sets the entity's state.
     * @param color New state
     */
    public void setState(final int state) {
        if (state == this.state.get()) return;
        filter.add(EntityStateFieldFilter.STATE);
        this.state.set(state);
    }

    /**
     * Sets the entity's state if the specified timestamp is after the current value's.
     * @param createdAt When the new value was generated by the other end
     * @param state New state
     */
    public void setState(final Instant createdAt, final int state) {
        this.state.set(createdAt, state);
    }   

    /**
     * Gets the entity's held item texture.
     * @return Held texture asset name
     */
    public String getHeldItemTexture() {
        return heldItemTexture.get();
    }

    /**
     * Sets the entity's held item texture.
     * @param heldItemTexture Held texture asset name
     */
    public void setHeldItemTexture(final String heldItemTexture) {
        if (heldItemTexture.equals(this.heldItemTexture.get())) return;
        filter.add(EntityStateFieldFilter.HELD_ITEM_TEXTURE);
        this.heldItemTexture.set(heldItemTexture);
    }

    /**
     * Sets the user's held item texture if the specified timestamp is after the current value's.
     * @param createdAt When the new value was generated by the other end
     * @param heldItemTexture New item texture
     */
    public void setHeldItemTexture(final Instant createdAt, final String heldItemTexture) {
        this.heldItemTexture.set(createdAt, heldItemTexture);
    }

    /**
     * Gets the entity's texture prefix.
     * @return Texture asset prefix
     */
    public String getTexturePrefix() {
        return texturePrefix;
    }

    /**
     * Gets the entity's unique ID.
     * @return ID
     */
    public int getId() {
        return id;
    }

    /**
     * Syncs any fields changed by the backend to all clients.
     */
    public void sync() {
        if (filter.size() == 0) return;

        // Run the entity state updater
        try {
            SpringMessageHandler.get().getCommandLoader().invokeMethodFor(
                GameType.BASIC, 
                MessageDataType.COMMAND_RECV_ENTITY_STATE
            ).run(
                SpringMessageHandler.get(),
                new RecvEntityStateInvokeContext(parent, this, filter)
            );
        } catch (final MessageFailure e) {
            LOGGER.error("Failed to send updated entity state to clients.", e);
            return;
        }

        filter.clear();
    }

    public static enum EntityStateFieldFilter {
        COORDINATES,
        ROTATION,
        HEALTH,
        HELD_ITEM_TEXTURE,
        STATE,
        TYPE,
        TEXTURE_PREFIX
    }
}
